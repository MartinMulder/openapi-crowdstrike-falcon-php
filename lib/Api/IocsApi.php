<?php
/**
 * IocsApi
 * PHP version 7.2
 *
 * @category Class
 * @package  OpenAPI\Client
 * @author   OpenAPI Generator team
 * @link     https://openapi-generator.tech
 */

/**
 * CrowdStrike API Specification
 *
 * Use this API specification as a reference for the API endpoints you can use to interact with your Falcon environment. These endpoints support authentication via OAuth2 and interact with detections and network containment. For detailed usage guides and examples, see our [documentation inside the Falcon console](https://falcon.eu-1.crowdstrike.com/support/documentation).     To use the APIs described below, combine the base URL with the path shown for each API endpoint. For commercial cloud customers, your base URL is `https://api.eu-1.crowdstrike.com`.    Each API endpoint requires authorization via an OAuth2 token. Your first API request should retrieve an OAuth2 token using the `oauth2/token` endpoint, such as `https://api.eu-1.crowdstrike.com/oauth2/token`. For subsequent requests, include the OAuth2 token in an HTTP authorization header. Tokens expire after 30 minutes, after which you should make a new token request to continue making API requests.
 *
 * The version of the OpenAPI document: 1.0.0-beta
 * 
 * Generated by: https://openapi-generator.tech
 * OpenAPI Generator version: 5.0.0
 */

/**
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

namespace OpenAPI\Client\Api;

use GuzzleHttp\Client;
use GuzzleHttp\ClientInterface;
use GuzzleHttp\Exception\RequestException;
use GuzzleHttp\Psr7\MultipartStream;
use GuzzleHttp\Psr7\Request;
use GuzzleHttp\RequestOptions;
use OpenAPI\Client\ApiException;
use OpenAPI\Client\Configuration;
use OpenAPI\Client\HeaderSelector;
use OpenAPI\Client\ObjectSerializer;

/**
 * IocsApi Class Doc Comment
 *
 * @category Class
 * @package  OpenAPI\Client
 * @author   OpenAPI Generator team
 * @link     https://openapi-generator.tech
 */
class IocsApi
{
    /**
     * @var ClientInterface
     */
    protected $client;

    /**
     * @var Configuration
     */
    protected $config;

    /**
     * @var HeaderSelector
     */
    protected $headerSelector;

    /**
     * @var int Host index
     */
    protected $hostIndex;

    /**
     * @param ClientInterface $client
     * @param Configuration   $config
     * @param HeaderSelector  $selector
     * @param int             $hostIndex (Optional) host index to select the list of hosts if defined in the OpenAPI spec
     */
    public function __construct(
        ClientInterface $client = null,
        Configuration $config = null,
        HeaderSelector $selector = null,
        $hostIndex = 0
    ) {
        $this->client = $client ?: new Client();
        $this->config = $config ?: new Configuration();
        $this->headerSelector = $selector ?: new HeaderSelector();
        $this->hostIndex = $hostIndex;
    }

    /**
     * Set the host index
     *
     * @param int $hostIndex Host index (required)
     */
    public function setHostIndex($hostIndex)
    {
        $this->hostIndex = $hostIndex;
    }

    /**
     * Get the host index
     *
     * @return int Host index
     */
    public function getHostIndex()
    {
        return $this->hostIndex;
    }

    /**
     * @return Configuration
     */
    public function getConfig()
    {
        return $this->config;
    }

    /**
     * Operation createIOC
     *
     * Create a new IOC
     *
     * @param  \OpenAPI\Client\Model\ApiIOCViewRecord[] $body Create a new IOC by providing a JSON object that includes these key/value pairs:  **type** (required): The type of the indicator. Valid values:  - sha256: A hex-encoded sha256 hash string. Length - min: 64, max: 64.  - md5: A hex-encoded md5 hash string. Length - min 32, max: 32.  - domain: A domain name. Length - min: 1, max: 200.  - ipv4: An IPv4 address. Must be a valid IP address.  - ipv6: An IPv6 address. Must be a valid IP address.  **value** (required): The string representation of the indicator.  **policy** (required): Action to take when a host observes the custom IOC. Values:  - detect: Enable detections for this custom IOC  - none: Disable detections for this custom IOC  **share_level** (optional): Visibility of this custom IOC. All custom IOCs are visible only within your customer account, so only one value is valid:  - red  **expiration_days** (optional): Number of days this custom IOC is active. Only applies for the types &#x60;domain&#x60;, &#x60;ipv4&#x60;, and &#x60;ipv6&#x60;.  **source** (optional): The source where this indicator originated. This can be used for tracking where this indicator was defined. Limit 200 characters.  **description** (optional): Descriptive label for this custom IOC (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\ApiMsaReplyIOC|\OpenAPI\Client\Model\MsaReplyMetaOnly|\OpenAPI\Client\Model\MsaReplyMetaOnly|\OpenAPI\Client\Model\ApiMsaReplyIOC
     */
    public function createIOC($body)
    {
        list($response) = $this->createIOCWithHttpInfo($body);
        return $response;
    }

    /**
     * Operation createIOCWithHttpInfo
     *
     * Create a new IOC
     *
     * @param  \OpenAPI\Client\Model\ApiIOCViewRecord[] $body Create a new IOC by providing a JSON object that includes these key/value pairs:  **type** (required): The type of the indicator. Valid values:  - sha256: A hex-encoded sha256 hash string. Length - min: 64, max: 64.  - md5: A hex-encoded md5 hash string. Length - min 32, max: 32.  - domain: A domain name. Length - min: 1, max: 200.  - ipv4: An IPv4 address. Must be a valid IP address.  - ipv6: An IPv6 address. Must be a valid IP address.  **value** (required): The string representation of the indicator.  **policy** (required): Action to take when a host observes the custom IOC. Values:  - detect: Enable detections for this custom IOC  - none: Disable detections for this custom IOC  **share_level** (optional): Visibility of this custom IOC. All custom IOCs are visible only within your customer account, so only one value is valid:  - red  **expiration_days** (optional): Number of days this custom IOC is active. Only applies for the types &#x60;domain&#x60;, &#x60;ipv4&#x60;, and &#x60;ipv6&#x60;.  **source** (optional): The source where this indicator originated. This can be used for tracking where this indicator was defined. Limit 200 characters.  **description** (optional): Descriptive label for this custom IOC (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\ApiMsaReplyIOC|\OpenAPI\Client\Model\MsaReplyMetaOnly|\OpenAPI\Client\Model\MsaReplyMetaOnly|\OpenAPI\Client\Model\ApiMsaReplyIOC, HTTP status code, HTTP response headers (array of strings)
     */
    public function createIOCWithHttpInfo($body)
    {
        $request = $this->createIOCRequest($body);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\ApiMsaReplyIOC' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\ApiMsaReplyIOC', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 403:
                    if ('\OpenAPI\Client\Model\MsaReplyMetaOnly' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\MsaReplyMetaOnly', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 429:
                    if ('\OpenAPI\Client\Model\MsaReplyMetaOnly' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\MsaReplyMetaOnly', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                default:
                    if ('\OpenAPI\Client\Model\ApiMsaReplyIOC' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\ApiMsaReplyIOC', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\ApiMsaReplyIOC';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = (string) $responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ApiMsaReplyIOC',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 403:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\MsaReplyMetaOnly',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 429:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\MsaReplyMetaOnly',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                default:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ApiMsaReplyIOC',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation createIOCAsync
     *
     * Create a new IOC
     *
     * @param  \OpenAPI\Client\Model\ApiIOCViewRecord[] $body Create a new IOC by providing a JSON object that includes these key/value pairs:  **type** (required): The type of the indicator. Valid values:  - sha256: A hex-encoded sha256 hash string. Length - min: 64, max: 64.  - md5: A hex-encoded md5 hash string. Length - min 32, max: 32.  - domain: A domain name. Length - min: 1, max: 200.  - ipv4: An IPv4 address. Must be a valid IP address.  - ipv6: An IPv6 address. Must be a valid IP address.  **value** (required): The string representation of the indicator.  **policy** (required): Action to take when a host observes the custom IOC. Values:  - detect: Enable detections for this custom IOC  - none: Disable detections for this custom IOC  **share_level** (optional): Visibility of this custom IOC. All custom IOCs are visible only within your customer account, so only one value is valid:  - red  **expiration_days** (optional): Number of days this custom IOC is active. Only applies for the types &#x60;domain&#x60;, &#x60;ipv4&#x60;, and &#x60;ipv6&#x60;.  **source** (optional): The source where this indicator originated. This can be used for tracking where this indicator was defined. Limit 200 characters.  **description** (optional): Descriptive label for this custom IOC (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createIOCAsync($body)
    {
        return $this->createIOCAsyncWithHttpInfo($body)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation createIOCAsyncWithHttpInfo
     *
     * Create a new IOC
     *
     * @param  \OpenAPI\Client\Model\ApiIOCViewRecord[] $body Create a new IOC by providing a JSON object that includes these key/value pairs:  **type** (required): The type of the indicator. Valid values:  - sha256: A hex-encoded sha256 hash string. Length - min: 64, max: 64.  - md5: A hex-encoded md5 hash string. Length - min 32, max: 32.  - domain: A domain name. Length - min: 1, max: 200.  - ipv4: An IPv4 address. Must be a valid IP address.  - ipv6: An IPv6 address. Must be a valid IP address.  **value** (required): The string representation of the indicator.  **policy** (required): Action to take when a host observes the custom IOC. Values:  - detect: Enable detections for this custom IOC  - none: Disable detections for this custom IOC  **share_level** (optional): Visibility of this custom IOC. All custom IOCs are visible only within your customer account, so only one value is valid:  - red  **expiration_days** (optional): Number of days this custom IOC is active. Only applies for the types &#x60;domain&#x60;, &#x60;ipv4&#x60;, and &#x60;ipv6&#x60;.  **source** (optional): The source where this indicator originated. This can be used for tracking where this indicator was defined. Limit 200 characters.  **description** (optional): Descriptive label for this custom IOC (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createIOCAsyncWithHttpInfo($body)
    {
        $returnType = '\OpenAPI\Client\Model\ApiMsaReplyIOC';
        $request = $this->createIOCRequest($body);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'createIOC'
     *
     * @param  \OpenAPI\Client\Model\ApiIOCViewRecord[] $body Create a new IOC by providing a JSON object that includes these key/value pairs:  **type** (required): The type of the indicator. Valid values:  - sha256: A hex-encoded sha256 hash string. Length - min: 64, max: 64.  - md5: A hex-encoded md5 hash string. Length - min 32, max: 32.  - domain: A domain name. Length - min: 1, max: 200.  - ipv4: An IPv4 address. Must be a valid IP address.  - ipv6: An IPv6 address. Must be a valid IP address.  **value** (required): The string representation of the indicator.  **policy** (required): Action to take when a host observes the custom IOC. Values:  - detect: Enable detections for this custom IOC  - none: Disable detections for this custom IOC  **share_level** (optional): Visibility of this custom IOC. All custom IOCs are visible only within your customer account, so only one value is valid:  - red  **expiration_days** (optional): Number of days this custom IOC is active. Only applies for the types &#x60;domain&#x60;, &#x60;ipv4&#x60;, and &#x60;ipv6&#x60;.  **source** (optional): The source where this indicator originated. This can be used for tracking where this indicator was defined. Limit 200 characters.  **description** (optional): Descriptive label for this custom IOC (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function createIOCRequest($body)
    {
        // verify the required parameter 'body' is set
        if ($body === null || (is_array($body) && count($body) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $body when calling createIOC'
            );
        }

        $resourcePath = '/indicators/entities/iocs/v1';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($body)) {
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($body));
            } else {
                $httpBody = $body;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation deleteIOC
     *
     * Delete an IOC by providing a type and value
     *
     * @param  string $type The type of the indicator. Valid types include:  sha256: A hex-encoded sha256 hash string. Length - min: 64, max: 64.  md5: A hex-encoded md5 hash string. Length - min 32, max: 32.  domain: A domain name. Length - min: 1, max: 200.  ipv4: An IPv4 address. Must be a valid IP address.  ipv6: An IPv6 address. Must be a valid IP address. (required)
     * @param  string $value The string representation of the indicator (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\ApiMsaReplyIOC|\OpenAPI\Client\Model\MsaReplyMetaOnly|\OpenAPI\Client\Model\MsaReplyMetaOnly|\OpenAPI\Client\Model\ApiMsaReplyIOC
     */
    public function deleteIOC($type, $value)
    {
        list($response) = $this->deleteIOCWithHttpInfo($type, $value);
        return $response;
    }

    /**
     * Operation deleteIOCWithHttpInfo
     *
     * Delete an IOC by providing a type and value
     *
     * @param  string $type The type of the indicator. Valid types include:  sha256: A hex-encoded sha256 hash string. Length - min: 64, max: 64.  md5: A hex-encoded md5 hash string. Length - min 32, max: 32.  domain: A domain name. Length - min: 1, max: 200.  ipv4: An IPv4 address. Must be a valid IP address.  ipv6: An IPv6 address. Must be a valid IP address. (required)
     * @param  string $value The string representation of the indicator (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\ApiMsaReplyIOC|\OpenAPI\Client\Model\MsaReplyMetaOnly|\OpenAPI\Client\Model\MsaReplyMetaOnly|\OpenAPI\Client\Model\ApiMsaReplyIOC, HTTP status code, HTTP response headers (array of strings)
     */
    public function deleteIOCWithHttpInfo($type, $value)
    {
        $request = $this->deleteIOCRequest($type, $value);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\ApiMsaReplyIOC' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\ApiMsaReplyIOC', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 403:
                    if ('\OpenAPI\Client\Model\MsaReplyMetaOnly' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\MsaReplyMetaOnly', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 429:
                    if ('\OpenAPI\Client\Model\MsaReplyMetaOnly' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\MsaReplyMetaOnly', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                default:
                    if ('\OpenAPI\Client\Model\ApiMsaReplyIOC' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\ApiMsaReplyIOC', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\ApiMsaReplyIOC';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = (string) $responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ApiMsaReplyIOC',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 403:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\MsaReplyMetaOnly',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 429:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\MsaReplyMetaOnly',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                default:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ApiMsaReplyIOC',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation deleteIOCAsync
     *
     * Delete an IOC by providing a type and value
     *
     * @param  string $type The type of the indicator. Valid types include:  sha256: A hex-encoded sha256 hash string. Length - min: 64, max: 64.  md5: A hex-encoded md5 hash string. Length - min 32, max: 32.  domain: A domain name. Length - min: 1, max: 200.  ipv4: An IPv4 address. Must be a valid IP address.  ipv6: An IPv6 address. Must be a valid IP address. (required)
     * @param  string $value The string representation of the indicator (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteIOCAsync($type, $value)
    {
        return $this->deleteIOCAsyncWithHttpInfo($type, $value)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation deleteIOCAsyncWithHttpInfo
     *
     * Delete an IOC by providing a type and value
     *
     * @param  string $type The type of the indicator. Valid types include:  sha256: A hex-encoded sha256 hash string. Length - min: 64, max: 64.  md5: A hex-encoded md5 hash string. Length - min 32, max: 32.  domain: A domain name. Length - min: 1, max: 200.  ipv4: An IPv4 address. Must be a valid IP address.  ipv6: An IPv6 address. Must be a valid IP address. (required)
     * @param  string $value The string representation of the indicator (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteIOCAsyncWithHttpInfo($type, $value)
    {
        $returnType = '\OpenAPI\Client\Model\ApiMsaReplyIOC';
        $request = $this->deleteIOCRequest($type, $value);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'deleteIOC'
     *
     * @param  string $type The type of the indicator. Valid types include:  sha256: A hex-encoded sha256 hash string. Length - min: 64, max: 64.  md5: A hex-encoded md5 hash string. Length - min 32, max: 32.  domain: A domain name. Length - min: 1, max: 200.  ipv4: An IPv4 address. Must be a valid IP address.  ipv6: An IPv6 address. Must be a valid IP address. (required)
     * @param  string $value The string representation of the indicator (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function deleteIOCRequest($type, $value)
    {
        // verify the required parameter 'type' is set
        if ($type === null || (is_array($type) && count($type) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $type when calling deleteIOC'
            );
        }
        // verify the required parameter 'value' is set
        if ($value === null || (is_array($value) && count($value) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $value when calling deleteIOC'
            );
        }

        $resourcePath = '/indicators/entities/iocs/v1';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if (is_array($type)) {
            $type = ObjectSerializer::serializeCollection($type, '', true);
        }
        if ($type !== null) {
            $queryParams['type'] = $type;
        }
        // query params
        if (is_array($value)) {
            $value = ObjectSerializer::serializeCollection($value, '', true);
        }
        if ($value !== null) {
            $queryParams['value'] = $value;
        }




        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'DELETE',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation devicesCount
     *
     * Number of hosts in your customer account that have observed a given custom IOC
     *
     * @param  string $type The type of the indicator. Valid types include:  sha256: A hex-encoded sha256 hash string. Length - min: 64, max: 64.  md5: A hex-encoded md5 hash string. Length - min 32, max: 32.  domain: A domain name. Length - min: 1, max: 200.  ipv4: An IPv4 address. Must be a valid IP address.  ipv6: An IPv6 address. Must be a valid IP address. (required)
     * @param  string $value The string representation of the indicator (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\ApiMsaReplyIOCDevicesCount|\OpenAPI\Client\Model\MsaReplyMetaOnly|\OpenAPI\Client\Model\MsaReplyMetaOnly|\OpenAPI\Client\Model\ApiMsaReplyIOCDevicesCount
     */
    public function devicesCount($type, $value)
    {
        list($response) = $this->devicesCountWithHttpInfo($type, $value);
        return $response;
    }

    /**
     * Operation devicesCountWithHttpInfo
     *
     * Number of hosts in your customer account that have observed a given custom IOC
     *
     * @param  string $type The type of the indicator. Valid types include:  sha256: A hex-encoded sha256 hash string. Length - min: 64, max: 64.  md5: A hex-encoded md5 hash string. Length - min 32, max: 32.  domain: A domain name. Length - min: 1, max: 200.  ipv4: An IPv4 address. Must be a valid IP address.  ipv6: An IPv6 address. Must be a valid IP address. (required)
     * @param  string $value The string representation of the indicator (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\ApiMsaReplyIOCDevicesCount|\OpenAPI\Client\Model\MsaReplyMetaOnly|\OpenAPI\Client\Model\MsaReplyMetaOnly|\OpenAPI\Client\Model\ApiMsaReplyIOCDevicesCount, HTTP status code, HTTP response headers (array of strings)
     */
    public function devicesCountWithHttpInfo($type, $value)
    {
        $request = $this->devicesCountRequest($type, $value);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\ApiMsaReplyIOCDevicesCount' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\ApiMsaReplyIOCDevicesCount', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 403:
                    if ('\OpenAPI\Client\Model\MsaReplyMetaOnly' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\MsaReplyMetaOnly', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 429:
                    if ('\OpenAPI\Client\Model\MsaReplyMetaOnly' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\MsaReplyMetaOnly', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                default:
                    if ('\OpenAPI\Client\Model\ApiMsaReplyIOCDevicesCount' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\ApiMsaReplyIOCDevicesCount', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\ApiMsaReplyIOCDevicesCount';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = (string) $responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ApiMsaReplyIOCDevicesCount',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 403:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\MsaReplyMetaOnly',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 429:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\MsaReplyMetaOnly',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                default:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ApiMsaReplyIOCDevicesCount',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation devicesCountAsync
     *
     * Number of hosts in your customer account that have observed a given custom IOC
     *
     * @param  string $type The type of the indicator. Valid types include:  sha256: A hex-encoded sha256 hash string. Length - min: 64, max: 64.  md5: A hex-encoded md5 hash string. Length - min 32, max: 32.  domain: A domain name. Length - min: 1, max: 200.  ipv4: An IPv4 address. Must be a valid IP address.  ipv6: An IPv6 address. Must be a valid IP address. (required)
     * @param  string $value The string representation of the indicator (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function devicesCountAsync($type, $value)
    {
        return $this->devicesCountAsyncWithHttpInfo($type, $value)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation devicesCountAsyncWithHttpInfo
     *
     * Number of hosts in your customer account that have observed a given custom IOC
     *
     * @param  string $type The type of the indicator. Valid types include:  sha256: A hex-encoded sha256 hash string. Length - min: 64, max: 64.  md5: A hex-encoded md5 hash string. Length - min 32, max: 32.  domain: A domain name. Length - min: 1, max: 200.  ipv4: An IPv4 address. Must be a valid IP address.  ipv6: An IPv6 address. Must be a valid IP address. (required)
     * @param  string $value The string representation of the indicator (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function devicesCountAsyncWithHttpInfo($type, $value)
    {
        $returnType = '\OpenAPI\Client\Model\ApiMsaReplyIOCDevicesCount';
        $request = $this->devicesCountRequest($type, $value);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'devicesCount'
     *
     * @param  string $type The type of the indicator. Valid types include:  sha256: A hex-encoded sha256 hash string. Length - min: 64, max: 64.  md5: A hex-encoded md5 hash string. Length - min 32, max: 32.  domain: A domain name. Length - min: 1, max: 200.  ipv4: An IPv4 address. Must be a valid IP address.  ipv6: An IPv6 address. Must be a valid IP address. (required)
     * @param  string $value The string representation of the indicator (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function devicesCountRequest($type, $value)
    {
        // verify the required parameter 'type' is set
        if ($type === null || (is_array($type) && count($type) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $type when calling devicesCount'
            );
        }
        // verify the required parameter 'value' is set
        if ($value === null || (is_array($value) && count($value) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $value when calling devicesCount'
            );
        }

        $resourcePath = '/indicators/aggregates/devices-count/v1';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if (is_array($type)) {
            $type = ObjectSerializer::serializeCollection($type, '', true);
        }
        if ($type !== null) {
            $queryParams['type'] = $type;
        }
        // query params
        if (is_array($value)) {
            $value = ObjectSerializer::serializeCollection($value, '', true);
        }
        if ($value !== null) {
            $queryParams['value'] = $value;
        }




        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation devicesRanOn
     *
     * Find hosts that have observed a given custom IOC. For details about those hosts, use GET /devices/entities/devices/v1
     *
     * @param  string $type The type of the indicator. Valid types include:  sha256: A hex-encoded sha256 hash string. Length - min: 64, max: 64.  md5: A hex-encoded md5 hash string. Length - min 32, max: 32.  domain: A domain name. Length - min: 1, max: 200.  ipv4: An IPv4 address. Must be a valid IP address.  ipv6: An IPv6 address. Must be a valid IP address. (required)
     * @param  string $value The string representation of the indicator (required)
     * @param  string $limit The first process to return, where 0 is the latest offset. Use with the offset parameter to manage pagination of results. (optional)
     * @param  string $offset The first process to return, where 0 is the latest offset. Use with the limit parameter to manage pagination of results. (optional)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\ApiMsaReplyDevicesRanOn|\OpenAPI\Client\Model\MsaReplyMetaOnly|\OpenAPI\Client\Model\MsaReplyMetaOnly|\OpenAPI\Client\Model\ApiMsaReplyDevicesRanOn
     */
    public function devicesRanOn($type, $value, $limit = null, $offset = null)
    {
        list($response) = $this->devicesRanOnWithHttpInfo($type, $value, $limit, $offset);
        return $response;
    }

    /**
     * Operation devicesRanOnWithHttpInfo
     *
     * Find hosts that have observed a given custom IOC. For details about those hosts, use GET /devices/entities/devices/v1
     *
     * @param  string $type The type of the indicator. Valid types include:  sha256: A hex-encoded sha256 hash string. Length - min: 64, max: 64.  md5: A hex-encoded md5 hash string. Length - min 32, max: 32.  domain: A domain name. Length - min: 1, max: 200.  ipv4: An IPv4 address. Must be a valid IP address.  ipv6: An IPv6 address. Must be a valid IP address. (required)
     * @param  string $value The string representation of the indicator (required)
     * @param  string $limit The first process to return, where 0 is the latest offset. Use with the offset parameter to manage pagination of results. (optional)
     * @param  string $offset The first process to return, where 0 is the latest offset. Use with the limit parameter to manage pagination of results. (optional)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\ApiMsaReplyDevicesRanOn|\OpenAPI\Client\Model\MsaReplyMetaOnly|\OpenAPI\Client\Model\MsaReplyMetaOnly|\OpenAPI\Client\Model\ApiMsaReplyDevicesRanOn, HTTP status code, HTTP response headers (array of strings)
     */
    public function devicesRanOnWithHttpInfo($type, $value, $limit = null, $offset = null)
    {
        $request = $this->devicesRanOnRequest($type, $value, $limit, $offset);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\ApiMsaReplyDevicesRanOn' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\ApiMsaReplyDevicesRanOn', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 403:
                    if ('\OpenAPI\Client\Model\MsaReplyMetaOnly' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\MsaReplyMetaOnly', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 429:
                    if ('\OpenAPI\Client\Model\MsaReplyMetaOnly' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\MsaReplyMetaOnly', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                default:
                    if ('\OpenAPI\Client\Model\ApiMsaReplyDevicesRanOn' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\ApiMsaReplyDevicesRanOn', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\ApiMsaReplyDevicesRanOn';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = (string) $responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ApiMsaReplyDevicesRanOn',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 403:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\MsaReplyMetaOnly',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 429:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\MsaReplyMetaOnly',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                default:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ApiMsaReplyDevicesRanOn',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation devicesRanOnAsync
     *
     * Find hosts that have observed a given custom IOC. For details about those hosts, use GET /devices/entities/devices/v1
     *
     * @param  string $type The type of the indicator. Valid types include:  sha256: A hex-encoded sha256 hash string. Length - min: 64, max: 64.  md5: A hex-encoded md5 hash string. Length - min 32, max: 32.  domain: A domain name. Length - min: 1, max: 200.  ipv4: An IPv4 address. Must be a valid IP address.  ipv6: An IPv6 address. Must be a valid IP address. (required)
     * @param  string $value The string representation of the indicator (required)
     * @param  string $limit The first process to return, where 0 is the latest offset. Use with the offset parameter to manage pagination of results. (optional)
     * @param  string $offset The first process to return, where 0 is the latest offset. Use with the limit parameter to manage pagination of results. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function devicesRanOnAsync($type, $value, $limit = null, $offset = null)
    {
        return $this->devicesRanOnAsyncWithHttpInfo($type, $value, $limit, $offset)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation devicesRanOnAsyncWithHttpInfo
     *
     * Find hosts that have observed a given custom IOC. For details about those hosts, use GET /devices/entities/devices/v1
     *
     * @param  string $type The type of the indicator. Valid types include:  sha256: A hex-encoded sha256 hash string. Length - min: 64, max: 64.  md5: A hex-encoded md5 hash string. Length - min 32, max: 32.  domain: A domain name. Length - min: 1, max: 200.  ipv4: An IPv4 address. Must be a valid IP address.  ipv6: An IPv6 address. Must be a valid IP address. (required)
     * @param  string $value The string representation of the indicator (required)
     * @param  string $limit The first process to return, where 0 is the latest offset. Use with the offset parameter to manage pagination of results. (optional)
     * @param  string $offset The first process to return, where 0 is the latest offset. Use with the limit parameter to manage pagination of results. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function devicesRanOnAsyncWithHttpInfo($type, $value, $limit = null, $offset = null)
    {
        $returnType = '\OpenAPI\Client\Model\ApiMsaReplyDevicesRanOn';
        $request = $this->devicesRanOnRequest($type, $value, $limit, $offset);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'devicesRanOn'
     *
     * @param  string $type The type of the indicator. Valid types include:  sha256: A hex-encoded sha256 hash string. Length - min: 64, max: 64.  md5: A hex-encoded md5 hash string. Length - min 32, max: 32.  domain: A domain name. Length - min: 1, max: 200.  ipv4: An IPv4 address. Must be a valid IP address.  ipv6: An IPv6 address. Must be a valid IP address. (required)
     * @param  string $value The string representation of the indicator (required)
     * @param  string $limit The first process to return, where 0 is the latest offset. Use with the offset parameter to manage pagination of results. (optional)
     * @param  string $offset The first process to return, where 0 is the latest offset. Use with the limit parameter to manage pagination of results. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function devicesRanOnRequest($type, $value, $limit = null, $offset = null)
    {
        // verify the required parameter 'type' is set
        if ($type === null || (is_array($type) && count($type) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $type when calling devicesRanOn'
            );
        }
        // verify the required parameter 'value' is set
        if ($value === null || (is_array($value) && count($value) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $value when calling devicesRanOn'
            );
        }

        $resourcePath = '/indicators/queries/devices/v1';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if (is_array($type)) {
            $type = ObjectSerializer::serializeCollection($type, '', true);
        }
        if ($type !== null) {
            $queryParams['type'] = $type;
        }
        // query params
        if (is_array($value)) {
            $value = ObjectSerializer::serializeCollection($value, '', true);
        }
        if ($value !== null) {
            $queryParams['value'] = $value;
        }
        // query params
        if (is_array($limit)) {
            $limit = ObjectSerializer::serializeCollection($limit, '', true);
        }
        if ($limit !== null) {
            $queryParams['limit'] = $limit;
        }
        // query params
        if (is_array($offset)) {
            $offset = ObjectSerializer::serializeCollection($offset, '', true);
        }
        if ($offset !== null) {
            $queryParams['offset'] = $offset;
        }




        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation entitiesProcesses
     *
     * For the provided ProcessID retrieve the process details
     *
     * @param  string[] $ids ProcessID for the running process you want to lookup (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\ApiMsaProcessDetailResponse|\OpenAPI\Client\Model\MsaReplyMetaOnly|\OpenAPI\Client\Model\MsaReplyMetaOnly|\OpenAPI\Client\Model\ApiMsaProcessDetailResponse
     */
    public function entitiesProcesses($ids)
    {
        list($response) = $this->entitiesProcessesWithHttpInfo($ids);
        return $response;
    }

    /**
     * Operation entitiesProcessesWithHttpInfo
     *
     * For the provided ProcessID retrieve the process details
     *
     * @param  string[] $ids ProcessID for the running process you want to lookup (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\ApiMsaProcessDetailResponse|\OpenAPI\Client\Model\MsaReplyMetaOnly|\OpenAPI\Client\Model\MsaReplyMetaOnly|\OpenAPI\Client\Model\ApiMsaProcessDetailResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function entitiesProcessesWithHttpInfo($ids)
    {
        $request = $this->entitiesProcessesRequest($ids);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\ApiMsaProcessDetailResponse' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\ApiMsaProcessDetailResponse', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 403:
                    if ('\OpenAPI\Client\Model\MsaReplyMetaOnly' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\MsaReplyMetaOnly', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 429:
                    if ('\OpenAPI\Client\Model\MsaReplyMetaOnly' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\MsaReplyMetaOnly', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                default:
                    if ('\OpenAPI\Client\Model\ApiMsaProcessDetailResponse' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\ApiMsaProcessDetailResponse', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\ApiMsaProcessDetailResponse';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = (string) $responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ApiMsaProcessDetailResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 403:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\MsaReplyMetaOnly',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 429:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\MsaReplyMetaOnly',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                default:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ApiMsaProcessDetailResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation entitiesProcessesAsync
     *
     * For the provided ProcessID retrieve the process details
     *
     * @param  string[] $ids ProcessID for the running process you want to lookup (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function entitiesProcessesAsync($ids)
    {
        return $this->entitiesProcessesAsyncWithHttpInfo($ids)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation entitiesProcessesAsyncWithHttpInfo
     *
     * For the provided ProcessID retrieve the process details
     *
     * @param  string[] $ids ProcessID for the running process you want to lookup (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function entitiesProcessesAsyncWithHttpInfo($ids)
    {
        $returnType = '\OpenAPI\Client\Model\ApiMsaProcessDetailResponse';
        $request = $this->entitiesProcessesRequest($ids);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'entitiesProcesses'
     *
     * @param  string[] $ids ProcessID for the running process you want to lookup (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function entitiesProcessesRequest($ids)
    {
        // verify the required parameter 'ids' is set
        if ($ids === null || (is_array($ids) && count($ids) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $ids when calling entitiesProcesses'
            );
        }

        $resourcePath = '/processes/entities/processes/v1';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($ids !== null) {
            if('form' === 'form' && is_array($ids)) {
                foreach($ids as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['ids'] = $ids;
            }
        }




        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getIOC
     *
     * Get an IOC by providing a type and value
     *
     * @param  string $type The type of the indicator. Valid types include:  sha256: A hex-encoded sha256 hash string. Length - min: 64, max: 64.  md5: A hex-encoded md5 hash string. Length - min 32, max: 32.  domain: A domain name. Length - min: 1, max: 200.  ipv4: An IPv4 address. Must be a valid IP address.  ipv6: An IPv6 address. Must be a valid IP address. (required)
     * @param  string $value The string representation of the indicator (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\ApiMsaReplyIOC|\OpenAPI\Client\Model\MsaReplyMetaOnly|\OpenAPI\Client\Model\MsaReplyMetaOnly|\OpenAPI\Client\Model\ApiMsaReplyIOC
     */
    public function getIOC($type, $value)
    {
        list($response) = $this->getIOCWithHttpInfo($type, $value);
        return $response;
    }

    /**
     * Operation getIOCWithHttpInfo
     *
     * Get an IOC by providing a type and value
     *
     * @param  string $type The type of the indicator. Valid types include:  sha256: A hex-encoded sha256 hash string. Length - min: 64, max: 64.  md5: A hex-encoded md5 hash string. Length - min 32, max: 32.  domain: A domain name. Length - min: 1, max: 200.  ipv4: An IPv4 address. Must be a valid IP address.  ipv6: An IPv6 address. Must be a valid IP address. (required)
     * @param  string $value The string representation of the indicator (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\ApiMsaReplyIOC|\OpenAPI\Client\Model\MsaReplyMetaOnly|\OpenAPI\Client\Model\MsaReplyMetaOnly|\OpenAPI\Client\Model\ApiMsaReplyIOC, HTTP status code, HTTP response headers (array of strings)
     */
    public function getIOCWithHttpInfo($type, $value)
    {
        $request = $this->getIOCRequest($type, $value);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\ApiMsaReplyIOC' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\ApiMsaReplyIOC', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 403:
                    if ('\OpenAPI\Client\Model\MsaReplyMetaOnly' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\MsaReplyMetaOnly', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 429:
                    if ('\OpenAPI\Client\Model\MsaReplyMetaOnly' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\MsaReplyMetaOnly', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                default:
                    if ('\OpenAPI\Client\Model\ApiMsaReplyIOC' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\ApiMsaReplyIOC', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\ApiMsaReplyIOC';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = (string) $responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ApiMsaReplyIOC',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 403:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\MsaReplyMetaOnly',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 429:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\MsaReplyMetaOnly',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                default:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ApiMsaReplyIOC',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getIOCAsync
     *
     * Get an IOC by providing a type and value
     *
     * @param  string $type The type of the indicator. Valid types include:  sha256: A hex-encoded sha256 hash string. Length - min: 64, max: 64.  md5: A hex-encoded md5 hash string. Length - min 32, max: 32.  domain: A domain name. Length - min: 1, max: 200.  ipv4: An IPv4 address. Must be a valid IP address.  ipv6: An IPv6 address. Must be a valid IP address. (required)
     * @param  string $value The string representation of the indicator (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getIOCAsync($type, $value)
    {
        return $this->getIOCAsyncWithHttpInfo($type, $value)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getIOCAsyncWithHttpInfo
     *
     * Get an IOC by providing a type and value
     *
     * @param  string $type The type of the indicator. Valid types include:  sha256: A hex-encoded sha256 hash string. Length - min: 64, max: 64.  md5: A hex-encoded md5 hash string. Length - min 32, max: 32.  domain: A domain name. Length - min: 1, max: 200.  ipv4: An IPv4 address. Must be a valid IP address.  ipv6: An IPv6 address. Must be a valid IP address. (required)
     * @param  string $value The string representation of the indicator (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getIOCAsyncWithHttpInfo($type, $value)
    {
        $returnType = '\OpenAPI\Client\Model\ApiMsaReplyIOC';
        $request = $this->getIOCRequest($type, $value);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getIOC'
     *
     * @param  string $type The type of the indicator. Valid types include:  sha256: A hex-encoded sha256 hash string. Length - min: 64, max: 64.  md5: A hex-encoded md5 hash string. Length - min 32, max: 32.  domain: A domain name. Length - min: 1, max: 200.  ipv4: An IPv4 address. Must be a valid IP address.  ipv6: An IPv6 address. Must be a valid IP address. (required)
     * @param  string $value The string representation of the indicator (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getIOCRequest($type, $value)
    {
        // verify the required parameter 'type' is set
        if ($type === null || (is_array($type) && count($type) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $type when calling getIOC'
            );
        }
        // verify the required parameter 'value' is set
        if ($value === null || (is_array($value) && count($value) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $value when calling getIOC'
            );
        }

        $resourcePath = '/indicators/entities/iocs/v1';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if (is_array($type)) {
            $type = ObjectSerializer::serializeCollection($type, '', true);
        }
        if ($type !== null) {
            $queryParams['type'] = $type;
        }
        // query params
        if (is_array($value)) {
            $value = ObjectSerializer::serializeCollection($value, '', true);
        }
        if ($value !== null) {
            $queryParams['value'] = $value;
        }




        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation processesRanOn
     *
     * Search for processes associated with a custom IOC
     *
     * @param  string $type The type of the indicator. Valid types include:  sha256: A hex-encoded sha256 hash string. Length - min: 64, max: 64.  md5: A hex-encoded md5 hash string. Length - min 32, max: 32.  domain: A domain name. Length - min: 1, max: 200.  ipv4: An IPv4 address. Must be a valid IP address.  ipv6: An IPv6 address. Must be a valid IP address. (required)
     * @param  string $value The string representation of the indicator (required)
     * @param  string $device_id Specify a host&#39;s ID to return only processes from that host. Get a host&#39;s ID from GET /devices/queries/devices/v1, the Falcon console, or the Streaming API. (required)
     * @param  string $limit The first process to return, where 0 is the latest offset. Use with the offset parameter to manage pagination of results. (optional)
     * @param  string $offset The first process to return, where 0 is the latest offset. Use with the limit parameter to manage pagination of results. (optional)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\ApiMsaReplyProcessesRanOn|\OpenAPI\Client\Model\MsaReplyMetaOnly|\OpenAPI\Client\Model\MsaReplyMetaOnly|\OpenAPI\Client\Model\ApiMsaReplyProcessesRanOn
     */
    public function processesRanOn($type, $value, $device_id, $limit = null, $offset = null)
    {
        list($response) = $this->processesRanOnWithHttpInfo($type, $value, $device_id, $limit, $offset);
        return $response;
    }

    /**
     * Operation processesRanOnWithHttpInfo
     *
     * Search for processes associated with a custom IOC
     *
     * @param  string $type The type of the indicator. Valid types include:  sha256: A hex-encoded sha256 hash string. Length - min: 64, max: 64.  md5: A hex-encoded md5 hash string. Length - min 32, max: 32.  domain: A domain name. Length - min: 1, max: 200.  ipv4: An IPv4 address. Must be a valid IP address.  ipv6: An IPv6 address. Must be a valid IP address. (required)
     * @param  string $value The string representation of the indicator (required)
     * @param  string $device_id Specify a host&#39;s ID to return only processes from that host. Get a host&#39;s ID from GET /devices/queries/devices/v1, the Falcon console, or the Streaming API. (required)
     * @param  string $limit The first process to return, where 0 is the latest offset. Use with the offset parameter to manage pagination of results. (optional)
     * @param  string $offset The first process to return, where 0 is the latest offset. Use with the limit parameter to manage pagination of results. (optional)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\ApiMsaReplyProcessesRanOn|\OpenAPI\Client\Model\MsaReplyMetaOnly|\OpenAPI\Client\Model\MsaReplyMetaOnly|\OpenAPI\Client\Model\ApiMsaReplyProcessesRanOn, HTTP status code, HTTP response headers (array of strings)
     */
    public function processesRanOnWithHttpInfo($type, $value, $device_id, $limit = null, $offset = null)
    {
        $request = $this->processesRanOnRequest($type, $value, $device_id, $limit, $offset);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\ApiMsaReplyProcessesRanOn' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\ApiMsaReplyProcessesRanOn', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 403:
                    if ('\OpenAPI\Client\Model\MsaReplyMetaOnly' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\MsaReplyMetaOnly', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 429:
                    if ('\OpenAPI\Client\Model\MsaReplyMetaOnly' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\MsaReplyMetaOnly', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                default:
                    if ('\OpenAPI\Client\Model\ApiMsaReplyProcessesRanOn' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\ApiMsaReplyProcessesRanOn', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\ApiMsaReplyProcessesRanOn';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = (string) $responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ApiMsaReplyProcessesRanOn',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 403:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\MsaReplyMetaOnly',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 429:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\MsaReplyMetaOnly',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                default:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ApiMsaReplyProcessesRanOn',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation processesRanOnAsync
     *
     * Search for processes associated with a custom IOC
     *
     * @param  string $type The type of the indicator. Valid types include:  sha256: A hex-encoded sha256 hash string. Length - min: 64, max: 64.  md5: A hex-encoded md5 hash string. Length - min 32, max: 32.  domain: A domain name. Length - min: 1, max: 200.  ipv4: An IPv4 address. Must be a valid IP address.  ipv6: An IPv6 address. Must be a valid IP address. (required)
     * @param  string $value The string representation of the indicator (required)
     * @param  string $device_id Specify a host&#39;s ID to return only processes from that host. Get a host&#39;s ID from GET /devices/queries/devices/v1, the Falcon console, or the Streaming API. (required)
     * @param  string $limit The first process to return, where 0 is the latest offset. Use with the offset parameter to manage pagination of results. (optional)
     * @param  string $offset The first process to return, where 0 is the latest offset. Use with the limit parameter to manage pagination of results. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function processesRanOnAsync($type, $value, $device_id, $limit = null, $offset = null)
    {
        return $this->processesRanOnAsyncWithHttpInfo($type, $value, $device_id, $limit, $offset)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation processesRanOnAsyncWithHttpInfo
     *
     * Search for processes associated with a custom IOC
     *
     * @param  string $type The type of the indicator. Valid types include:  sha256: A hex-encoded sha256 hash string. Length - min: 64, max: 64.  md5: A hex-encoded md5 hash string. Length - min 32, max: 32.  domain: A domain name. Length - min: 1, max: 200.  ipv4: An IPv4 address. Must be a valid IP address.  ipv6: An IPv6 address. Must be a valid IP address. (required)
     * @param  string $value The string representation of the indicator (required)
     * @param  string $device_id Specify a host&#39;s ID to return only processes from that host. Get a host&#39;s ID from GET /devices/queries/devices/v1, the Falcon console, or the Streaming API. (required)
     * @param  string $limit The first process to return, where 0 is the latest offset. Use with the offset parameter to manage pagination of results. (optional)
     * @param  string $offset The first process to return, where 0 is the latest offset. Use with the limit parameter to manage pagination of results. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function processesRanOnAsyncWithHttpInfo($type, $value, $device_id, $limit = null, $offset = null)
    {
        $returnType = '\OpenAPI\Client\Model\ApiMsaReplyProcessesRanOn';
        $request = $this->processesRanOnRequest($type, $value, $device_id, $limit, $offset);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'processesRanOn'
     *
     * @param  string $type The type of the indicator. Valid types include:  sha256: A hex-encoded sha256 hash string. Length - min: 64, max: 64.  md5: A hex-encoded md5 hash string. Length - min 32, max: 32.  domain: A domain name. Length - min: 1, max: 200.  ipv4: An IPv4 address. Must be a valid IP address.  ipv6: An IPv6 address. Must be a valid IP address. (required)
     * @param  string $value The string representation of the indicator (required)
     * @param  string $device_id Specify a host&#39;s ID to return only processes from that host. Get a host&#39;s ID from GET /devices/queries/devices/v1, the Falcon console, or the Streaming API. (required)
     * @param  string $limit The first process to return, where 0 is the latest offset. Use with the offset parameter to manage pagination of results. (optional)
     * @param  string $offset The first process to return, where 0 is the latest offset. Use with the limit parameter to manage pagination of results. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function processesRanOnRequest($type, $value, $device_id, $limit = null, $offset = null)
    {
        // verify the required parameter 'type' is set
        if ($type === null || (is_array($type) && count($type) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $type when calling processesRanOn'
            );
        }
        // verify the required parameter 'value' is set
        if ($value === null || (is_array($value) && count($value) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $value when calling processesRanOn'
            );
        }
        // verify the required parameter 'device_id' is set
        if ($device_id === null || (is_array($device_id) && count($device_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $device_id when calling processesRanOn'
            );
        }

        $resourcePath = '/indicators/queries/processes/v1';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if (is_array($type)) {
            $type = ObjectSerializer::serializeCollection($type, '', true);
        }
        if ($type !== null) {
            $queryParams['type'] = $type;
        }
        // query params
        if (is_array($value)) {
            $value = ObjectSerializer::serializeCollection($value, '', true);
        }
        if ($value !== null) {
            $queryParams['value'] = $value;
        }
        // query params
        if (is_array($device_id)) {
            $device_id = ObjectSerializer::serializeCollection($device_id, '', true);
        }
        if ($device_id !== null) {
            $queryParams['device_id'] = $device_id;
        }
        // query params
        if (is_array($limit)) {
            $limit = ObjectSerializer::serializeCollection($limit, '', true);
        }
        if ($limit !== null) {
            $queryParams['limit'] = $limit;
        }
        // query params
        if (is_array($offset)) {
            $offset = ObjectSerializer::serializeCollection($offset, '', true);
        }
        if ($offset !== null) {
            $queryParams['offset'] = $offset;
        }




        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation queryIOCs
     *
     * Search the custom IOCs in your customer account
     *
     * @param  string $types The type of the indicator. Valid types include:  sha256: A hex-encoded sha256 hash string. Length - min: 64, max: 64.  md5: A hex-encoded md5 hash string. Length - min 32, max: 32.  domain: A domain name. Length - min: 1, max: 200.  ipv4: An IPv4 address. Must be a valid IP address.  ipv6: An IPv6 address. Must be a valid IP address. (optional)
     * @param  string $values The string representation of the indicator (optional)
     * @param  string $from_expiration_timestamp Find custom IOCs created after this time (RFC-3339 timestamp) (optional)
     * @param  string $to_expiration_timestamp Find custom IOCs created before this time (RFC-3339 timestamp) (optional)
     * @param  string $policies \\ndetect: Find custom IOCs that produce notifications\\n\\nnone: Find custom IOCs the particular indicator has been detected on a host. This is equivalent to turning the indicator off. (optional)
     * @param  string $sources The source where this indicator originated. This can be used for tracking where this indicator was defined. Limit 200 characters. (optional)
     * @param  string $share_levels The level at which the indicator will be shared. Currently only red share level (not shared) is supported, indicating that the IOC isn&#39;t shared with other FH customers. (optional)
     * @param  string $created_by created_by (optional)
     * @param  string $deleted_by The user or API client who deleted the custom IOC (optional)
     * @param  string $include_deleted true: Include deleted IOCs  false: Don&#39;t include deleted IOCs (default) (optional)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\ApiMsaReplyIOCIDs|\OpenAPI\Client\Model\MsaReplyMetaOnly|\OpenAPI\Client\Model\MsaReplyMetaOnly|\OpenAPI\Client\Model\ApiMsaReplyIOCIDs
     */
    public function queryIOCs($types = null, $values = null, $from_expiration_timestamp = null, $to_expiration_timestamp = null, $policies = null, $sources = null, $share_levels = null, $created_by = null, $deleted_by = null, $include_deleted = null)
    {
        list($response) = $this->queryIOCsWithHttpInfo($types, $values, $from_expiration_timestamp, $to_expiration_timestamp, $policies, $sources, $share_levels, $created_by, $deleted_by, $include_deleted);
        return $response;
    }

    /**
     * Operation queryIOCsWithHttpInfo
     *
     * Search the custom IOCs in your customer account
     *
     * @param  string $types The type of the indicator. Valid types include:  sha256: A hex-encoded sha256 hash string. Length - min: 64, max: 64.  md5: A hex-encoded md5 hash string. Length - min 32, max: 32.  domain: A domain name. Length - min: 1, max: 200.  ipv4: An IPv4 address. Must be a valid IP address.  ipv6: An IPv6 address. Must be a valid IP address. (optional)
     * @param  string $values The string representation of the indicator (optional)
     * @param  string $from_expiration_timestamp Find custom IOCs created after this time (RFC-3339 timestamp) (optional)
     * @param  string $to_expiration_timestamp Find custom IOCs created before this time (RFC-3339 timestamp) (optional)
     * @param  string $policies \\ndetect: Find custom IOCs that produce notifications\\n\\nnone: Find custom IOCs the particular indicator has been detected on a host. This is equivalent to turning the indicator off. (optional)
     * @param  string $sources The source where this indicator originated. This can be used for tracking where this indicator was defined. Limit 200 characters. (optional)
     * @param  string $share_levels The level at which the indicator will be shared. Currently only red share level (not shared) is supported, indicating that the IOC isn&#39;t shared with other FH customers. (optional)
     * @param  string $created_by created_by (optional)
     * @param  string $deleted_by The user or API client who deleted the custom IOC (optional)
     * @param  string $include_deleted true: Include deleted IOCs  false: Don&#39;t include deleted IOCs (default) (optional)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\ApiMsaReplyIOCIDs|\OpenAPI\Client\Model\MsaReplyMetaOnly|\OpenAPI\Client\Model\MsaReplyMetaOnly|\OpenAPI\Client\Model\ApiMsaReplyIOCIDs, HTTP status code, HTTP response headers (array of strings)
     */
    public function queryIOCsWithHttpInfo($types = null, $values = null, $from_expiration_timestamp = null, $to_expiration_timestamp = null, $policies = null, $sources = null, $share_levels = null, $created_by = null, $deleted_by = null, $include_deleted = null)
    {
        $request = $this->queryIOCsRequest($types, $values, $from_expiration_timestamp, $to_expiration_timestamp, $policies, $sources, $share_levels, $created_by, $deleted_by, $include_deleted);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\ApiMsaReplyIOCIDs' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\ApiMsaReplyIOCIDs', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 403:
                    if ('\OpenAPI\Client\Model\MsaReplyMetaOnly' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\MsaReplyMetaOnly', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 429:
                    if ('\OpenAPI\Client\Model\MsaReplyMetaOnly' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\MsaReplyMetaOnly', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                default:
                    if ('\OpenAPI\Client\Model\ApiMsaReplyIOCIDs' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\ApiMsaReplyIOCIDs', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\ApiMsaReplyIOCIDs';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = (string) $responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ApiMsaReplyIOCIDs',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 403:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\MsaReplyMetaOnly',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 429:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\MsaReplyMetaOnly',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                default:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ApiMsaReplyIOCIDs',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation queryIOCsAsync
     *
     * Search the custom IOCs in your customer account
     *
     * @param  string $types The type of the indicator. Valid types include:  sha256: A hex-encoded sha256 hash string. Length - min: 64, max: 64.  md5: A hex-encoded md5 hash string. Length - min 32, max: 32.  domain: A domain name. Length - min: 1, max: 200.  ipv4: An IPv4 address. Must be a valid IP address.  ipv6: An IPv6 address. Must be a valid IP address. (optional)
     * @param  string $values The string representation of the indicator (optional)
     * @param  string $from_expiration_timestamp Find custom IOCs created after this time (RFC-3339 timestamp) (optional)
     * @param  string $to_expiration_timestamp Find custom IOCs created before this time (RFC-3339 timestamp) (optional)
     * @param  string $policies \\ndetect: Find custom IOCs that produce notifications\\n\\nnone: Find custom IOCs the particular indicator has been detected on a host. This is equivalent to turning the indicator off. (optional)
     * @param  string $sources The source where this indicator originated. This can be used for tracking where this indicator was defined. Limit 200 characters. (optional)
     * @param  string $share_levels The level at which the indicator will be shared. Currently only red share level (not shared) is supported, indicating that the IOC isn&#39;t shared with other FH customers. (optional)
     * @param  string $created_by created_by (optional)
     * @param  string $deleted_by The user or API client who deleted the custom IOC (optional)
     * @param  string $include_deleted true: Include deleted IOCs  false: Don&#39;t include deleted IOCs (default) (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function queryIOCsAsync($types = null, $values = null, $from_expiration_timestamp = null, $to_expiration_timestamp = null, $policies = null, $sources = null, $share_levels = null, $created_by = null, $deleted_by = null, $include_deleted = null)
    {
        return $this->queryIOCsAsyncWithHttpInfo($types, $values, $from_expiration_timestamp, $to_expiration_timestamp, $policies, $sources, $share_levels, $created_by, $deleted_by, $include_deleted)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation queryIOCsAsyncWithHttpInfo
     *
     * Search the custom IOCs in your customer account
     *
     * @param  string $types The type of the indicator. Valid types include:  sha256: A hex-encoded sha256 hash string. Length - min: 64, max: 64.  md5: A hex-encoded md5 hash string. Length - min 32, max: 32.  domain: A domain name. Length - min: 1, max: 200.  ipv4: An IPv4 address. Must be a valid IP address.  ipv6: An IPv6 address. Must be a valid IP address. (optional)
     * @param  string $values The string representation of the indicator (optional)
     * @param  string $from_expiration_timestamp Find custom IOCs created after this time (RFC-3339 timestamp) (optional)
     * @param  string $to_expiration_timestamp Find custom IOCs created before this time (RFC-3339 timestamp) (optional)
     * @param  string $policies \\ndetect: Find custom IOCs that produce notifications\\n\\nnone: Find custom IOCs the particular indicator has been detected on a host. This is equivalent to turning the indicator off. (optional)
     * @param  string $sources The source where this indicator originated. This can be used for tracking where this indicator was defined. Limit 200 characters. (optional)
     * @param  string $share_levels The level at which the indicator will be shared. Currently only red share level (not shared) is supported, indicating that the IOC isn&#39;t shared with other FH customers. (optional)
     * @param  string $created_by created_by (optional)
     * @param  string $deleted_by The user or API client who deleted the custom IOC (optional)
     * @param  string $include_deleted true: Include deleted IOCs  false: Don&#39;t include deleted IOCs (default) (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function queryIOCsAsyncWithHttpInfo($types = null, $values = null, $from_expiration_timestamp = null, $to_expiration_timestamp = null, $policies = null, $sources = null, $share_levels = null, $created_by = null, $deleted_by = null, $include_deleted = null)
    {
        $returnType = '\OpenAPI\Client\Model\ApiMsaReplyIOCIDs';
        $request = $this->queryIOCsRequest($types, $values, $from_expiration_timestamp, $to_expiration_timestamp, $policies, $sources, $share_levels, $created_by, $deleted_by, $include_deleted);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'queryIOCs'
     *
     * @param  string $types The type of the indicator. Valid types include:  sha256: A hex-encoded sha256 hash string. Length - min: 64, max: 64.  md5: A hex-encoded md5 hash string. Length - min 32, max: 32.  domain: A domain name. Length - min: 1, max: 200.  ipv4: An IPv4 address. Must be a valid IP address.  ipv6: An IPv6 address. Must be a valid IP address. (optional)
     * @param  string $values The string representation of the indicator (optional)
     * @param  string $from_expiration_timestamp Find custom IOCs created after this time (RFC-3339 timestamp) (optional)
     * @param  string $to_expiration_timestamp Find custom IOCs created before this time (RFC-3339 timestamp) (optional)
     * @param  string $policies \\ndetect: Find custom IOCs that produce notifications\\n\\nnone: Find custom IOCs the particular indicator has been detected on a host. This is equivalent to turning the indicator off. (optional)
     * @param  string $sources The source where this indicator originated. This can be used for tracking where this indicator was defined. Limit 200 characters. (optional)
     * @param  string $share_levels The level at which the indicator will be shared. Currently only red share level (not shared) is supported, indicating that the IOC isn&#39;t shared with other FH customers. (optional)
     * @param  string $created_by created_by (optional)
     * @param  string $deleted_by The user or API client who deleted the custom IOC (optional)
     * @param  string $include_deleted true: Include deleted IOCs  false: Don&#39;t include deleted IOCs (default) (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function queryIOCsRequest($types = null, $values = null, $from_expiration_timestamp = null, $to_expiration_timestamp = null, $policies = null, $sources = null, $share_levels = null, $created_by = null, $deleted_by = null, $include_deleted = null)
    {

        $resourcePath = '/indicators/queries/iocs/v1';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if (is_array($types)) {
            $types = ObjectSerializer::serializeCollection($types, '', true);
        }
        if ($types !== null) {
            $queryParams['types'] = $types;
        }
        // query params
        if (is_array($values)) {
            $values = ObjectSerializer::serializeCollection($values, '', true);
        }
        if ($values !== null) {
            $queryParams['values'] = $values;
        }
        // query params
        if (is_array($from_expiration_timestamp)) {
            $from_expiration_timestamp = ObjectSerializer::serializeCollection($from_expiration_timestamp, '', true);
        }
        if ($from_expiration_timestamp !== null) {
            $queryParams['from.expiration_timestamp'] = $from_expiration_timestamp;
        }
        // query params
        if (is_array($to_expiration_timestamp)) {
            $to_expiration_timestamp = ObjectSerializer::serializeCollection($to_expiration_timestamp, '', true);
        }
        if ($to_expiration_timestamp !== null) {
            $queryParams['to.expiration_timestamp'] = $to_expiration_timestamp;
        }
        // query params
        if (is_array($policies)) {
            $policies = ObjectSerializer::serializeCollection($policies, '', true);
        }
        if ($policies !== null) {
            $queryParams['policies'] = $policies;
        }
        // query params
        if (is_array($sources)) {
            $sources = ObjectSerializer::serializeCollection($sources, '', true);
        }
        if ($sources !== null) {
            $queryParams['sources'] = $sources;
        }
        // query params
        if (is_array($share_levels)) {
            $share_levels = ObjectSerializer::serializeCollection($share_levels, '', true);
        }
        if ($share_levels !== null) {
            $queryParams['share_levels'] = $share_levels;
        }
        // query params
        if (is_array($created_by)) {
            $created_by = ObjectSerializer::serializeCollection($created_by, '', true);
        }
        if ($created_by !== null) {
            $queryParams['created_by'] = $created_by;
        }
        // query params
        if (is_array($deleted_by)) {
            $deleted_by = ObjectSerializer::serializeCollection($deleted_by, '', true);
        }
        if ($deleted_by !== null) {
            $queryParams['deleted_by'] = $deleted_by;
        }
        // query params
        if (is_array($include_deleted)) {
            $include_deleted = ObjectSerializer::serializeCollection($include_deleted, '', true);
        }
        if ($include_deleted !== null) {
            $queryParams['include_deleted'] = $include_deleted;
        }




        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation updateIOC
     *
     * Update an IOC by providing a type and value
     *
     * @param  string $type The type of the indicator. Valid types include:  sha256: A hex-encoded sha256 hash string. Length - min: 64, max: 64.  md5: A hex-encoded md5 hash string. Length - min 32, max: 32.  domain: A domain name. Length - min: 1, max: 200.  ipv4: An IPv4 address. Must be a valid IP address.  ipv6: An IPv6 address. Must be a valid IP address. (required)
     * @param  string $value The string representation of the indicator (required)
     * @param  \OpenAPI\Client\Model\ApiIOCViewRecord $body body (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\ApiMsaReplyIOC|\OpenAPI\Client\Model\MsaReplyMetaOnly|\OpenAPI\Client\Model\MsaReplyMetaOnly|\OpenAPI\Client\Model\ApiMsaReplyIOC
     */
    public function updateIOC($type, $value, $body)
    {
        list($response) = $this->updateIOCWithHttpInfo($type, $value, $body);
        return $response;
    }

    /**
     * Operation updateIOCWithHttpInfo
     *
     * Update an IOC by providing a type and value
     *
     * @param  string $type The type of the indicator. Valid types include:  sha256: A hex-encoded sha256 hash string. Length - min: 64, max: 64.  md5: A hex-encoded md5 hash string. Length - min 32, max: 32.  domain: A domain name. Length - min: 1, max: 200.  ipv4: An IPv4 address. Must be a valid IP address.  ipv6: An IPv6 address. Must be a valid IP address. (required)
     * @param  string $value The string representation of the indicator (required)
     * @param  \OpenAPI\Client\Model\ApiIOCViewRecord $body (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\ApiMsaReplyIOC|\OpenAPI\Client\Model\MsaReplyMetaOnly|\OpenAPI\Client\Model\MsaReplyMetaOnly|\OpenAPI\Client\Model\ApiMsaReplyIOC, HTTP status code, HTTP response headers (array of strings)
     */
    public function updateIOCWithHttpInfo($type, $value, $body)
    {
        $request = $this->updateIOCRequest($type, $value, $body);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\ApiMsaReplyIOC' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\ApiMsaReplyIOC', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 403:
                    if ('\OpenAPI\Client\Model\MsaReplyMetaOnly' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\MsaReplyMetaOnly', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 429:
                    if ('\OpenAPI\Client\Model\MsaReplyMetaOnly' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\MsaReplyMetaOnly', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                default:
                    if ('\OpenAPI\Client\Model\ApiMsaReplyIOC' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\ApiMsaReplyIOC', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\ApiMsaReplyIOC';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = (string) $responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ApiMsaReplyIOC',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 403:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\MsaReplyMetaOnly',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 429:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\MsaReplyMetaOnly',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                default:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ApiMsaReplyIOC',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation updateIOCAsync
     *
     * Update an IOC by providing a type and value
     *
     * @param  string $type The type of the indicator. Valid types include:  sha256: A hex-encoded sha256 hash string. Length - min: 64, max: 64.  md5: A hex-encoded md5 hash string. Length - min 32, max: 32.  domain: A domain name. Length - min: 1, max: 200.  ipv4: An IPv4 address. Must be a valid IP address.  ipv6: An IPv6 address. Must be a valid IP address. (required)
     * @param  string $value The string representation of the indicator (required)
     * @param  \OpenAPI\Client\Model\ApiIOCViewRecord $body (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updateIOCAsync($type, $value, $body)
    {
        return $this->updateIOCAsyncWithHttpInfo($type, $value, $body)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation updateIOCAsyncWithHttpInfo
     *
     * Update an IOC by providing a type and value
     *
     * @param  string $type The type of the indicator. Valid types include:  sha256: A hex-encoded sha256 hash string. Length - min: 64, max: 64.  md5: A hex-encoded md5 hash string. Length - min 32, max: 32.  domain: A domain name. Length - min: 1, max: 200.  ipv4: An IPv4 address. Must be a valid IP address.  ipv6: An IPv6 address. Must be a valid IP address. (required)
     * @param  string $value The string representation of the indicator (required)
     * @param  \OpenAPI\Client\Model\ApiIOCViewRecord $body (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updateIOCAsyncWithHttpInfo($type, $value, $body)
    {
        $returnType = '\OpenAPI\Client\Model\ApiMsaReplyIOC';
        $request = $this->updateIOCRequest($type, $value, $body);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'updateIOC'
     *
     * @param  string $type The type of the indicator. Valid types include:  sha256: A hex-encoded sha256 hash string. Length - min: 64, max: 64.  md5: A hex-encoded md5 hash string. Length - min 32, max: 32.  domain: A domain name. Length - min: 1, max: 200.  ipv4: An IPv4 address. Must be a valid IP address.  ipv6: An IPv6 address. Must be a valid IP address. (required)
     * @param  string $value The string representation of the indicator (required)
     * @param  \OpenAPI\Client\Model\ApiIOCViewRecord $body (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function updateIOCRequest($type, $value, $body)
    {
        // verify the required parameter 'type' is set
        if ($type === null || (is_array($type) && count($type) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $type when calling updateIOC'
            );
        }
        // verify the required parameter 'value' is set
        if ($value === null || (is_array($value) && count($value) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $value when calling updateIOC'
            );
        }
        // verify the required parameter 'body' is set
        if ($body === null || (is_array($body) && count($body) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $body when calling updateIOC'
            );
        }

        $resourcePath = '/indicators/entities/iocs/v1';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if (is_array($type)) {
            $type = ObjectSerializer::serializeCollection($type, '', true);
        }
        if ($type !== null) {
            $queryParams['type'] = $type;
        }
        // query params
        if (is_array($value)) {
            $value = ObjectSerializer::serializeCollection($value, '', true);
        }
        if ($value !== null) {
            $queryParams['value'] = $value;
        }




        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($body)) {
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($body));
            } else {
                $httpBody = $body;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'PATCH',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Create http client option
     *
     * @throws \RuntimeException on file opening failure
     * @return array of http client options
     */
    protected function createHttpClientOption()
    {
        $options = [];
        if ($this->config->getDebug()) {
            $options[RequestOptions::DEBUG] = fopen($this->config->getDebugFile(), 'a');
            if (!$options[RequestOptions::DEBUG]) {
                throw new \RuntimeException('Failed to open the debug file: ' . $this->config->getDebugFile());
            }
        }

        return $options;
    }
}
